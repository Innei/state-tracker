---
title: Reaction
sidebar_position: 4
---

```ts
const reaction = new Reaction({
  fn: (state: ProxyState) => any,
  state: proxyState,
  scheduler: (fn: Function) => any,
}, props?: any | Array<any>);
```

## Params

- `fn`: `autoRun`函数，它会在`Reaction`初始化的时候执行一次，然后在每一次记录的`state`中的值发生变化的时候重新执行一次
- `state`: `produce`生成的`Proxy object`，它会作为`fn`的第一个参数被使用，`fn`中所有使用到它的节点都会被跟踪
- `scheduler`: 默认是`(fn: Function) => fn.call(this)`；但是假如你想将`fn`放到下一个`event loop`可以通过这个方式实现
- `props`: 作为`fn`的第二个参数传递给`fn`，这个就类似组件渲染时的`props`

### fn

```ts
type Fn = (state: ProxyState) => any
```

- 第一个参数是`state`

## State & Props

在`Reaction`中它有两个重要的概念是`state`和`props`；之所以，这么设计是借鉴了目前组件的普遍的渲染模式，
- 组件有自己的域值，称之为`state`
- 组件有上游传下来的值，称之为`props`

:::note
1. fn中第一个参数是`state`，第二个参数是可选的`props`
2. 如果只有使用到的`props`值发生变化，是不会触发`re-run`
3. 如果`props`发生了变化，同时`state`发生了变化，那么在`fn`中可以拿到最新的`state`和`props`
:::

### Examples

#### state中值的变化会触发re-run

```ts
const state = { app: { a1: 1, a2: 2 } };
const proxyState = produce(state);
let count = 0

new Reaction({
  fn: (state, props) => {
    console.log('a1 ', state.app.a1);
    count++;
  },
  state: proxyState,
});

console.log('count1 ', count)   // 1
StateTrackerUtil.setValue(
  proxyState, {
    app: { a1: 2, a2: 2 },
  }
)

console.log('count2 ', count) // 2
```

#### 只有props的变化，不会触发`rerun`

```ts
const state = { app: { a1: 1, a2: 2 } };
const data = { data: [{ title: 'first' }]}
const proxyState = produce(state);
const proxyData = produce(data)
let count = 0

new Reaction({
  fn: (state, props) => {
    console.log('title ', props.data[0].title);
    count++;
  },
  state: proxyState,
}, proxyData);

console.log('count1 ', count)   // 1
StateTrackerUtil.setValue(
  proxyData, {
    data: [{ title: 'second' }]
  }
)

console.log('count2 ', count) // 1
```

#### 当state也发生变化时，才能够将props的最新值应用上

```ts
const state = { app: { a1: 1, a2: 2 } };
const data = { data: [{ title: 'first' }]}
const proxyState = produce(state);
const proxyData = produce(data)
let count = 0

new Reaction({
  fn: (state, props) => {
    console.log('a1 ', state.app.a1)
    console.log('title ', props.data[0].title);
    count++;
  },
  state: proxyState,
}, proxyData);

console.log('count1 ', count)   // 1
StateTrackerUtil.setValue(
  proxyData, {
    data: [{ title: 'second' }]
  }
)
StateTrackerUtil.setValue(
  proxyState, {
    app: { a1: 2, a2: 2 }
  }
)

console.log('count2 ', count) // 1
```